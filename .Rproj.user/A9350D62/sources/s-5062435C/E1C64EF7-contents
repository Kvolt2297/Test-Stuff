
#R Library Project - Kirill Volodko

#1 Basics
#2 Cool Functions
#3 Making Functions
#4 Making a Graph


#------------------------------Basics------------------------------------------

#Beginnings (Objects, Syntax and Naming)
x <- sqrt(22) # Setting object x as sqrt(22)
y <- 12 #Setting object y as 12
#In order for the function below to work, you got to run x and y
#objects first, so their values can be remembered by R
x*y
z <- x*y #Results could be stored in a third variable. However it will 
#overwrite it.
print(z) # Print the content of the object 
2+2 == 4 # == shows if the equation is true or false
2+2 == 5 
3 <= 4 # <= less or equal to. True or False
"Z"<"Q" # < greater than... True or False. Seems to work on a characters. 
#B is greater than A? 
"Banana"!="Apple" # != not equal to. 
 

#Vectors
# Used to represent variables. R can assign sets of numbers & characters
#to named variables using command c()
# c() stands for concatenate 

#Assigning Values to an Object
Cool <- c(1,2,22,222,231,5,-16,192,-149,33)
walk<- c(-5.19, -1.20, -0.50, -0.33, -0.15, -0.15, -0.15, 
         -0.07, 0.02, 0.02, 0.28, 0.37, 0.45, 1.76, 2.80)  
# c() allows to construct a whole list of numbers, that can be assigned to an 
# object or more.

Cool[] #[] is to extract or replace a certain value in vector, matricies, arrays
       # and lists. 

which (Cool<0) # The which command will identify the elements 
               # corresponding to TRUE. Basically which vector is TRUE. 
Cool[5] <- 0 # Indicators (<-) can be used to change values of a certain 
             #vector in the variable. Here we changed 5th number to equal 0.
Cool[c(1,3,6)] <- 2 #haha, you can do that with multiple numbers at once

mydata <- data.frame(Cool=Cool, Warm=Warm, z=z, stringsAsFactors = FALSE) 
#putting vectors into data frame under mydata variable. 
#stringAsFactor = FALSE command is optional, but recommended to preserve 
 
print(mydata) #Remember that data frames are not vectors! 
#Thus commands like lenght(x) or length (mydata) won't do any good.
#Instead use mydata$x or mydata$y
mydata$Warm #I can used named variables inside frame.data

#Finding Medium
sort(z) #Places values in order of their value, not in placement
z[1:8] <- sort(z) # Place all the values in order for z
mean(z[4:5]) #Find medium between 4th and 5th number in the vector

#Basic Arguments

mean() #Finds a mean of a list or columns
sd() #Find standard deviation
median() #Finds the median from the list of numbers
sqrt() #Square root a number 
# Note that these arguments won't simply work in data frames (mean, sd, median)

#Define Parameters
mean.cricket <- 5.2                     #taken from een et al. 2018
sd.cricket <- 1.32
sample.size <- 12 
col.thor <-c("blue","red") #color of the figures. Each color has a value that-
#can be recalled in future fucntion
str(col.thor) #tells me what col.thor contains (blue, red)
class(col.thor) #what type of data is it. col.thor is character

d <- rnorm(5, 5, 2) #draw from a normal distribution
hist(d)             #making a histogram
?rnorm              #look up the help function. In this case I am looking for
                    #normal distribution.

# Indexing
list.files() #show all the files in the working directory
getwd() #represents current filepath on the computer. 
setwd() #used to get a return from a file path. 
m <- read.csv(file.choose(), stringsAsFactors = FALSE)
head(m) #show first few entries
str(m) #Displays internal structure of an object. 
nrow(m) #Amount of rows in data.frame 
ncol(m) #Amount of columns in data.frame
list(m) #Shows me (in a list form) what is inside object or data.frame
m[1:10, 5] #Brackets in the data frame. 1st number is row, 2nd is a column.
table(m$status) #asking for table of status fron m
table(m$continent, m$family) #same as above, but asking continent and family
                             #variable info.



#------------------------------Useful Functions-------------------------------

#Function 
function()
#Provides means to create your own function. Look further in "Making a Function"
  
#Unique 
unique() #Returns a values from vector, data frame or array, removing the 
#duplicates

#Length 
length() # counts how many vectors (values) are in the list or data frame. 
         # Often could be indicated as "n" .

#Log
log() or log10() #change values in the vector, data frame or array into logs

#Transpose
reverse.widow<-t(reverse.widow) 
#t() flips the rows and columns of the table. Pretty cool.

#Aggregate
aggregate(salmon.data$skinColor ~ salmon.data$species,  FUN = sd)
#aggregate helps to separate two variables and conduct a fucntion on both
#FUN simply applies a function onto all of the list that were seperated.

#Chi-Square Test
chisq.test(bird.frequency2$Observed, NULL, correct = TRUE,  
           p = rep(1/length(bird.frequency2$Observed), 
                   length(bird.frequency2$Observed)), rescale.p = FALSE, 
           simulate.p.value = FALSE, B = 2000)
#Performs a chi-square test. Still don't know significance of all the other
#arguments in a function, but they work and I don't mess with them.

#T-test
t.test(beer.glass$drinkingMinutes ~ beer.glass$glassShape, var.equal = TRUE, 
       na.rm = TRUE)
#t.test performs a t-test.
#var.equal = TRUE establishes an assumption that variances are same
#na.rm = TRUE removes all of the missing data out of the calculation

#Fisher's test
fisher.test(prairie.dog2$Birth2, prairie.dog2$noBirth2) 
#Performs fishers test
#Table 
table(Mammals$continent) #sorts data into a table form.
#Looking at how many mammal species are in the continent

#Which
which(Mammals$continent == "Af") #Finding spelling mistake 
#which90 allows to find TRUE values/indicies in an object or data frame
#useful if I need to find certain things that share a comminality. 
#In this case, I am look for "Af" from the continent data.
Mammals$continent[Mammals$continent == "Af"] <- "AF"#Fixing the spelling mistake

#Drop Levels
Mammals$continent<-droplevels(Mammals$continent)
#get rids of unused rows in the data frame. Then assign it to the new column in 
#the data frame.

#grep
grep("extinct", Mammals$status)
#Finds for matches in the argument - pattern. Basically helps me to find 
#frequency of certain variable in data frame

vertical.var <- length(bird.window$angleDuringBirdCrash
                       [grep("vertical",  bird.window$angleDuringBirdCrash)]) 
#using grep to create new vector. In this case I am asking for all of the 
#values in the "vertical" varialbe to be accounted.

#------------------------------Making a Functions------------------------------
#All that function does is automating things
potatoes <- c(3,6,7,3,5,7,5)
mean(potatoes)
#Making function for mean

#Function definition
thor.mean <- function(list.of.potatoes) { #New type of brackets. Define function
  sum.temp <-sum(list.of.potatoes) #we need a sum of
  #whatever enters functions, it will enter function as "list.of.potatoes"
  length.val.temp <- length(list.of.potatoes)
#Get the sample size number.
  new.mean <- sum.temp/length.val.temp
#Find the mean
  return(new.mean)
#Show the number on the console
    }
thor.mean(potatoes)

#Figuring out the mode. (found it on the web)
rmode <- function(v) {          #function(v) is saying to r that I am making new
  uniqv <- unique(v)            #function for my use. It's stored under 
  uniqv[which.max(tabulate(match(v, uniqv)))] # "Funcitons". (v) is a set of
}                               #arguments, that are usually placeholders for
rmode(walk)                     #objects
#unique function returns a set of numbers, but does not repeat duplicates

#------------------------------Making a Graph---------------------------------

#Putting graph in order
Mammals$Continent_ordered <-factor(Mammals$continent, levels = names
                          (sort(table(Mammals$continent), decreasing = TRUE))) 
#ordering continents according to their factor values. 
#This creates a new vector within the data frame.

#making a plot 
plot(mean.cricket, sd.cricket, col = col.thor[1])
points(5, 1.1, col=col.thor[2])

#Drawing from the binomial distribution
dbinom(1:10, size = 10, prob = 0.2)

qnorm(sample.size, mean.cricket, sd.cricket)

#Bar Graph
ggplot(Mammals, aes (x = Mammals$Continent_ordered))+ 
#It's important to include + when you want to add/change things to the bar graph
  labs(x = "Continent", y="Species Count") + #labs is for changing labels
  geom_bar(stat="count") + 
#geom_bar is to create a bar graph. 
  theme_classic() #Making it classy. Sets up a background.

#Baisc Histogram
hist(x) #simplest histogram command. 
hist(x, right = FALSE) #The default in R is to use right-closed, left-open 
#intervals. To change to left-closed right-open, use the comman right = FALSE

#Histogram
ggplot(Mammals, aes(x = Mammals$mass.grams))+
  geom_histogram(fill = "red", col = "black",
                 binwidth = 0.1, boundary = 0, closed = "right")+
  #histogram requires binwidth(width), boundary and closed to have a readable 
  #graph
  labs(x = "Mammals Mass", y = "Frequency") #Naming x and y

#Mutliple histograpms
ggplot(Mammals, aes(x = Mammals$mass.grams))+
  geom_histogram(fill = "red", col = "black", 
                 binwidth = 0.1, boundary = 0, closed = "left")+
  labs(x = "Mammals Mass", y = "Frequency")+
  facet_wrap(~Mammals$status, ncol = 1, scales = "free_y")+ 
  theme_classic()

#Histogram axis 
hist(salmon.data$skinColor[salmon.data$species == "sockeye"], 
     breaks = seq(min(salmon.data$skinColor), max(salmon.data$skinColor), 
                  length.out = 10))
#Breaks = seq helps me to establish same axis measurments. Also length out 
#helps with the compile the data together. 

#Quantile plot.
ggplot(Mammals, aes(sample = Mammals$mass.grams))+  
  geom_qq() + #this is enough to create the basic one
  geom_qq_line() + 
  theme_dark() #dark theme... wouldn't recommend
#Quantile plot seems to be better to get the general idea of trends 
#and patterns, but histogram density seems to be more informative and detailed.

#Boxplot
ggplot(Mammals, aes(y = Mammals$mass.grams, x = Mammals$status)) +
  geom_boxplot(fill = "purple", varwidth = TRUE, notch = FALSE) +
  labs(x = "Status", y = "Log10 Body Mass")

#Violin Plot
ggplot(Mammals, aes(y = Mammals$mass.grams, x = Mammals$status)) +
  geom_violin(fill = "purple") +
  stat_summary(fun.y = mean, geom = "point", color = "black")+ 
  #fun.y is a function for y-axis. In this case I want my y (Mammals$mass.grams)
  #be a mean
  labs(x = "Status", y = "Log10 Body Mass")

#Scatter Plot
ggplot(fruitfly,aes(fruitfly$thorax.mm, fruitfly$longevity.days,
                    colour = treatment, shape = treatment)) +  
#coulour = treatment, shape = treatment add a legend and colorize the variables
  geom_point(size = 2, alpha = 0.5) + #alpha is how transparent the points are
  geom_smooth(method = "lm", size = 1, se = FALSE) + 
  #This adds the regression line for each of the group.
  labs(x = "Thorax Size (mm)", y = "Longetivity") + 
  theme(aspect.ratio = 0.80) + #size of the text on the graph
  theme_classic()

#Making a strip chart
ggplot(fruitfly, aes(fruitfly$treatment, fruitfly$longevity.days)) 
+ geom_jitter(color = "firebrick", size = 3, width = 0.15)+ 
  labs(x ="Treatment", y="Longitivity")

#Column Names
colnames(bird.frequency2)<- c("Observed", "Expected", "(O-E)^2 / E")
#Renames your columns inside the data frame. 

#Row Names
row(bird.frequency2)<- c(1, 2, 3, 4, 5, 6 ,7 ,8)
#Same thing as column names, but for the rows in the data frame

